ADR 003. 검색 기능 아키텍처 결정

# 상태

- 승인됨 (2026-01-17)

# 컨텍스트

GitHub Code Search API를 사용하여 검색 결과를 가져오고, 사용자 정의 필터를
적용하는 기능을 구현해야 합니다.

## 핵심 문제

1. **필터링으로 인한 결과 부족**
   - GitHub API는 페이지당 최대 100개 결과 반환
   - 사용자 필터 적용 시 결과가 크게 줄어듦 (예: 100개 → 15개)
   - 한 페이지를 채우기 위해 여러 페이지를 fetch해야 함

2. **페이지네이션의 비효율성**
   - 사용자가 Page 10으로 이동 시 Page 1~9의 모든 결과를 불러와야 함
   - 각 결과의 repository 정보까지 fetch하면 수백 개의 API 호출 발생
   - Rate limit (10 req/min) 초과 위험

3. **GitHub API 제약사항**
   - Rate limit: 10 requests/minute (authenticated)
   - 페이지당 최대 100개 결과
   - Repository 정보는 별도 API 호출 필요

# 결정

## 1. Cursor-based Infinite Scroll 채택

전통적인 페이지네이션 대신 **커서 기반 무한 스크롤**을 사용합니다.

### 동작 방식

- 페이지 번호 대신 "마지막으로 본 항목"을 기준으로 다음 결과 로드
- 필터링 후 결과가 부족하면 자동으로 다음 페이지 fetch
- 사용자는 스크롤만 하면 자연스럽게 추가 결과 로드

### 선택 이유

- ✅ **효율적인 API 사용**: 필요한 만큼만 fetch
- ✅ **Rate limit 관리 용이**: 순차적 로딩으로 제어 가능
- ✅ **빠른 초기 로딩**: 첫 페이지만 로드
- ✅ **자연스러운 UX**: GitHub, Twitter 등과 동일한 패턴
- ✅ **필터링에 최적화**: 결과 부족 시 자동 보충

### 포기한 것

- ❌ 특정 페이지로 직접 이동 불가
- ❌ URL 공유 시 정확한 위치 복원 어려움

## 2. Filtrex 라이브러리 사용

필터 표현식 파싱에 **filtrex** 라이브러리를 사용합니다.

### 선택 이유

- ✅ 안전한 표현식 평가 (`eval()` 사용 안 함)
- ✅ 검증된 라이브러리 (보안 취약점 최소화)
- ✅ 직접 구현 대비 개발 시간 단축
- ✅ 유지보수 용이

## 3. Repository 정보 전체 Fetch

필터링을 위해 **모든 repository 정보를 fetch**합니다.

### 선택 이유

- ✅ **Redis 캐싱 준비**: 나중에 Redis 추가 시 캐싱 가능
- ✅ **필터링 정확도**: 모든 필드 사용 가능
- ✅ **단순한 로직**: 선택적 fetch보다 구현 간단

### 최적화 전략

- 병렬 API 호출 (`Promise.all`)
- Redis 캐싱으로 중복 호출 방지 (Phase 3)

# 영향

## 긍정적 영향

- 효율적인 API 사용으로 Rate limit 문제 해결
- 빠른 초기 로딩으로 사용자 경험 개선
- Redis 캐싱 추가 시 성능 대폭 향상 가능

## 부정적 영향

- URL 공유 기능 제한 (검색어/필터만 공유 가능, 스크롤 위치는 불가)
- 페이지네이션에 익숙한 사용자에게 낯설 수 있음

## 기술 스택 추가

- **filtrex**: 필터 표현식 파싱
- **IntersectionObserver**: 무한 스크롤 구현

# 변경 사항

- 2026-01-17: 초안 작성 및 승인
